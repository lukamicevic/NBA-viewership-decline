{"version":3,"sources":["../src/index.ts","../src/utils.ts","../src/debug-offset.tsx","../src/step.tsx","../src/provide.tsx","../src/scrollama.tsx"],"sourcesContent":["export * from \"./debug-offset\";\nexport * from \"./types\";\nexport * from \"./utils\";\nexport * from \"./step\";\nexport * from \"./scrollama\";\nexport * from \"./provide\";\n","import type { TriggerLineDirection } from \"./types\";\n\n/**\n * Checks if the given offset is in pixels.\n *\n * @param offset - The offset to check.\n * @returns Returns true if the offset is a string and includes 'px', otherwise false.\n */\nexport function isOffsetInPixels(offset: unknown) {\n  return typeof offset === \"string\" && offset.includes(\"px\");\n}\n\n/**\n * Creates an array of threshold values for intersection observer.\n *\n * @param theta - The step size for creating thresholds.\n * @param height - The total height to be divided into thresholds.\n * @returns An array of threshold values between 0 and 1.\n */\nexport const createThreshold = (theta: number, height: number) => {\n  const count = Math.ceil(height / theta);\n  const t: number[] = [];\n  const ratio = 1 / count;\n  for (let i = 0; i <= count; i += 1) {\n    t.push(i * ratio);\n  }\n  return t;\n};\n\n/**\n * Checks if the current environment is a browser.\n *\n * @returns {boolean} Returns true if running in a browser environment, false otherwise.\n */\nexport const isBrowser =\n  typeof window !== \"undefined\" && window.document !== undefined;\n\nexport const isHorizontal = (direction: TriggerLineDirection) =>\n  direction === \"horizontal\";\n\n/**\n * Calculates the root margin for the Intersection Observer based on the given offset.\n *\n * @param {Object} params - The parameters object.\n * @param {number} params.offset - The offset value, typically between 0 and 1.\n * @param {TriggerLineDirection} params.direction - The direction of the trigger line.\n * @returns {string} The calculated root margin string in the format \"top right bottom left\".\n */\nexport const getRootMargin = ({\n  offset,\n  direction,\n}: {\n  offset: number;\n  direction: TriggerLineDirection;\n}) => {\n  const calculateMargin = (offset: number) => `${-offset * 100}%`;\n  const calculateOppositeMargin = (offset: number) =>\n    `${-(100 - offset * 100)}%`;\n\n  if (isHorizontal(direction)) {\n    return [\n      calculateMargin(offset), // Top\n      \"0px\", // Right\n      calculateOppositeMargin(offset), // Bottom\n      \"0px\", // Left\n    ].join(\" \");\n  }\n\n  return [\n    \"0px\", // Top\n    calculateOppositeMargin(offset), // Right\n    \"0px\", // Bottom\n    calculateMargin(offset), // Left\n  ].join(\" \");\n};\n\ninterface GetProgressRootMarginParams {\n  offset: number;\n  nodeSize: number;\n  containerSize: number;\n  direction: TriggerLineDirection;\n}\n\n/**\n * Calculates the root margin for progress tracking based on scroll direction and element dimensions.\n *\n * @param {Object} params - The parameters for calculating the root margin.\n * @param {number} params.offset - The offset value, typically between 0 and 1.\n * @param {number} params.nodeSize - The size of the node.\n * @param {number} params.containerSize - The size of the container.\n * @param {TriggerLineDirection} params.direction - The direction of the trigger line.\n * @returns {string} The calculated root margin string in the format \"top right bottom left\".\n */\nexport const getProgressRootMargin = ({\n  offset,\n  nodeSize,\n  containerSize,\n  direction,\n}: GetProgressRootMarginParams) => {\n  if (!nodeSize) return \"0px\";\n  const offsetSizeRatio = nodeSize / containerSize;\n  if (!isHorizontal(direction)) {\n    return `0px ${offset * 100 - 100}% 0px ${(offsetSizeRatio - offset) * 100 + 1}%`;\n  }\n  /**\n   * @see https://developer.mozilla.org/en-US/docs/Web/API/Intersection_Observer_API\n   * Add an extra 1% to prevent the \"zero intersection rectangle\" phenomenon:\n   *\n   * 1. Prevents the root intersection rectangle from overlapping with the scrolling element, which could prevent triggering.\n   * 2. Due to rounding of decimal points in calculations, the height of the root intersection rectangle might be smaller than the scrolling element's height, preventing triggering.\n   *\n   * Why adding 1% doesn't affect progress calculation:\n   *\n   * When the intersection ratio of the scrolling observer is 1, the other observer's isIntersecting is false.\n   * Therefore, we don't need to worry about the impact of adding this extra value.\n   */\n  return `${(offsetSizeRatio - offset) * 100 + 1}% 0px ${offset * 100 - 100}% 0px`;\n};\n","import type { TriggerLineDirection } from \"./types\";\n\nimport { isHorizontal, isOffsetInPixels } from \"./utils\";\n\nconst markerStylesVertical: React.CSSProperties = {\n  top: 0,\n  width: 0,\n  height: \"100%\",\n  borderLeft: \"2px dashed black\",\n  zIndex: 9999,\n};\n\nconst markerStylesHorizontal: React.CSSProperties = {\n  left: 0,\n  width: \"100%\",\n  height: 0,\n  borderTop: \"2px dashed black\",\n  zIndex: 9999,\n};\n\nconst offsetTextStyles: React.CSSProperties = {\n  fontSize: \"12px\",\n  fontFamily: \"monospace\",\n  margin: 0,\n  padding: 6,\n};\n\nconst getOffsetValue = (offset: string | number, containerSize: number) => {\n  const offsetInPixels = isOffsetInPixels(offset);\n\n  if (offsetInPixels) {\n    return offset.toString();\n  }\n  return `${Number(offset) * containerSize}px`;\n};\n\ninterface DebugOffsetProps {\n  offset: string | number;\n  containerSize: number;\n  stickySize: number;\n  isHasRoot?: boolean;\n  direction: TriggerLineDirection;\n}\n\nexport const DebugOffset: React.FC<DebugOffsetProps> = ({\n  offset,\n  direction,\n  stickySize,\n  isHasRoot,\n  containerSize,\n}) => {\n  const offsetValue = getOffsetValue(offset, containerSize);\n  const commonStyles = isHorizontal(direction)\n    ? {\n        ...markerStylesHorizontal,\n        top: offsetValue,\n      }\n    : {\n        ...markerStylesVertical,\n        left: offsetValue,\n      };\n\n  return isHasRoot ? (\n    <div style={{ position: \"sticky\", top: 0, left: 0 }}>\n      <div\n        style={{\n          ...commonStyles,\n          position: \"absolute\",\n          ...(isHorizontal(direction)\n            ? { width: stickySize }\n            : { height: stickySize }),\n        }}\n      >\n        <p style={offsetTextStyles}>trigger: {offset}</p>\n      </div>\n    </div>\n  ) : (\n    <div style={{ ...commonStyles, position: \"fixed\" }}>\n      <p style={offsetTextStyles}>trigger: {offset}</p>\n    </div>\n  );\n};\n","import {\n  Children,\n  cloneElement,\n  useCallback,\n  useContext,\n  useEffect,\n  useLayoutEffect,\n  useMemo,\n  useRef,\n  useState,\n} from \"react\";\nimport { useInView } from \"react-intersection-observer\";\n\nimport { ScrollamaProvide } from \"./provide\";\nimport type { ScrollamaCallbackData, StepProps } from \"./types\";\nimport {\n  getProgressRootMargin,\n  getRootMargin,\n  isBrowser,\n  isHorizontal,\n} from \"./utils\";\n\nexport const Step: React.FC<StepProps> = ({ children, data }) => {\n  const {\n    handleSetLastScrollPosition = () => {},\n    lastScrollPosition = 0,\n    onStepEnter = () => {},\n    onStepExit = () => {},\n    onStepProgress = null,\n    offset = 0.3,\n    progressThreshold,\n    containerSize = 0,\n    rootRef,\n    direction = \"horizontal\",\n  } = useContext(ScrollamaProvide);\n\n  const [nodeSize, setNodeSize] = useState(0);\n  const rootMargin = getRootMargin({ offset, direction });\n  const { ref: inViewRef, entry } = useInView({\n    root: rootRef?.current,\n    rootMargin,\n    threshold: 0,\n  });\n\n  const getScrollPosition = () => {\n    if (!isBrowser) return 0;\n    if (rootRef?.current) {\n      return isHorizontal(direction)\n        ? rootRef.current.scrollTop\n        : rootRef.current.scrollLeft;\n    }\n    return isHorizontal(direction) ? window.scrollY : window.scrollX;\n  };\n\n  const getScrollDirection = () => {\n    if (isHorizontal(direction)) {\n      return lastScrollPosition > getScrollPosition() ? \"up\" : \"down\";\n    }\n    return lastScrollPosition > getScrollPosition() ? \"left\" : \"right\";\n  };\n\n  const ref = useRef<HTMLElement | null>(null);\n  const [isIntersecting, setIsIntersecting] = useState(false);\n\n  const progressRootMargin = useMemo(\n    () => getProgressRootMargin({ offset, nodeSize, containerSize, direction }),\n    [offset, nodeSize, containerSize, direction],\n  );\n\n  const { ref: scrollProgressRef, entry: scrollProgressEntry } = useInView({\n    root: rootRef?.current,\n    rootMargin: progressRootMargin,\n    threshold: progressThreshold,\n  });\n\n  const setRefs = useCallback(\n    (node: HTMLElement) => {\n      ref.current = node;\n      inViewRef(node);\n      scrollProgressRef(node);\n    },\n    [inViewRef, scrollProgressRef],\n  );\n\n  useEffect(() => {\n    if (isIntersecting && scrollProgressEntry) {\n      const progress = scrollProgressEntry.intersectionRatio;\n      if (onStepProgress) {\n        onStepProgress({\n          progress: progress,\n          data,\n          element: scrollProgressEntry.target,\n          entry: scrollProgressEntry,\n          direction: getScrollDirection(),\n        });\n      }\n    }\n  }, [scrollProgressEntry]);\n\n  useEffect(() => {\n    if (entry) {\n      const currentIntersectionState = entry.isIntersecting;\n      if (currentIntersectionState !== isIntersecting) {\n        setIsIntersecting(currentIntersectionState);\n        const eventData: ScrollamaCallbackData<unknown> = {\n          element: entry.target,\n          data,\n          entry,\n          direction: getScrollDirection(),\n        };\n        if (currentIntersectionState) {\n          onStepEnter(eventData);\n        } else {\n          onStepExit(eventData);\n        }\n        handleSetLastScrollPosition(getScrollPosition());\n      }\n    }\n  }, [entry]);\n\n  useLayoutEffect(() => {\n    if (ref.current) {\n      setNodeSize(\n        isHorizontal(direction)\n          ? ref.current.offsetHeight\n          : ref.current.offsetWidth,\n      );\n    }\n  }, [ref.current]);\n\n  const childElement = Children.only(children);\n  // @ts-ignore\n  return cloneElement(childElement, { ref: setRefs });\n};\n","import { createContext } from \"react\";\n\nimport type { ScrollamaProvideProps } from \"./types\";\n\n/**\n * @see https://react.dev/reference/react/createContext#createcontext\n */\nexport const ScrollamaProvide = createContext<ScrollamaProvideProps<unknown>>(\n  {},\n);\n","import { useEffect, useMemo, useState } from \"react\";\n\nimport { DebugOffset } from \"./debug-offset\";\nimport { ScrollamaProvide } from \"./provide\";\nimport { createThreshold, isHorizontal, isOffsetInPixels } from \"./utils\";\n\nimport type { ScrollamaProps } from \"./types\";\n\nexport const Scrollama = <T = unknown,>({\n  direction = \"horizontal\",\n  debug,\n  children,\n  offset = 0.3,\n  onStepEnter,\n  onStepExit,\n  onStepProgress,\n  threshold = 4,\n  rootRef,\n}: ScrollamaProps<T>) => {\n  const isOffsetDefinedInPixels = isOffsetInPixels(offset);\n  const [lastScrollPosition, setLastScrollPosition] = useState(0);\n  const [containerSize, setContainerSize] = useState(1);\n  const [stickySize, setStickySize] = useState(0);\n\n  const viewportSize = useMemo(() => {\n    return isHorizontal(direction) ? window.innerHeight : window.innerWidth;\n  }, [direction]);\n\n  const handleSetLastScrollPosition = (scrollPosition: number) => {\n    setLastScrollPosition(scrollPosition);\n  };\n\n  const handleResize = () => {\n    if (rootRef?.current) {\n      setContainerSize(\n        isHorizontal(direction)\n          ? rootRef.current.clientHeight\n          : rootRef.current.clientWidth,\n      );\n      setStickySize(\n        !isHorizontal(direction)\n          ? rootRef.current.clientHeight\n          : rootRef.current.clientWidth,\n      );\n    } else {\n      setContainerSize(viewportSize);\n    }\n  };\n\n  useEffect(() => {\n    if (isOffsetDefinedInPixels) {\n      if (rootRef?.current) {\n        const resizeObserver = new ResizeObserver(() => {\n          handleResize();\n        });\n        resizeObserver.observe(rootRef.current);\n        return () => {\n          resizeObserver.disconnect();\n        };\n      }\n\n      handleResize();\n      window.addEventListener(\"resize\", handleResize);\n      return () => {\n        window.removeEventListener(\"resize\", handleResize);\n      };\n    }\n  }, []);\n\n  const offsetValue = isOffsetDefinedInPixels\n    ? +(offset as string).replace(\"px\", \"\") / containerSize\n    : +offset;\n\n  const progressThreshold = useMemo(\n    () => createThreshold(threshold, containerSize),\n    [containerSize],\n  );\n\n  return (\n    <ScrollamaProvide.Provider\n      value={{\n        offset: offsetValue,\n        lastScrollPosition,\n        handleSetLastScrollPosition,\n        progressThreshold,\n        containerSize,\n        rootRef,\n        direction,\n        // @ts-ignore ts(2345)\n        onStepEnter,\n        // @ts-ignore ts(2345)\n        onStepExit,\n        // @ts-ignore ts(2345)\n        onStepProgress,\n      }}\n    >\n      {debug && (\n        <DebugOffset\n          offset={offset}\n          direction={direction}\n          isHasRoot={!!rootRef}\n          stickySize={stickySize}\n          containerSize={containerSize}\n        />\n      )}\n      {children}\n    </ScrollamaProvide.Provider>\n  );\n};\n"],"mappings":";;;;;;;;;;;;;;;;;;;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;;ACQO,SAAS,iBAAiB,QAAiB;AAChD,SAAO,OAAO,WAAW,YAAY,OAAO,SAAS,IAAI;AAC3D;AASO,IAAM,kBAAkB,CAAC,OAAe,WAAmB;AAChE,QAAM,QAAQ,KAAK,KAAK,SAAS,KAAK;AACtC,QAAM,IAAc,CAAC;AACrB,QAAM,QAAQ,IAAI;AAClB,WAAS,IAAI,GAAG,KAAK,OAAO,KAAK,GAAG;AAClC,MAAE,KAAK,IAAI,KAAK;AAAA,EAClB;AACA,SAAO;AACT;AAOO,IAAM,YACX,OAAO,WAAW,eAAe,OAAO,aAAa;AAEhD,IAAM,eAAe,CAAC,cAC3B,cAAc;AAUT,IAAM,gBAAgB,CAAC;AAAA,EAC5B;AAAA,EACA;AACF,MAGM;AACJ,QAAM,kBAAkB,CAACA,YAAmB,GAAG,CAACA,UAAS,GAAG;AAC5D,QAAM,0BAA0B,CAACA,YAC/B,GAAG,EAAE,MAAMA,UAAS,IAAI;AAE1B,MAAI,aAAa,SAAS,GAAG;AAC3B,WAAO;AAAA,MACL,gBAAgB,MAAM;AAAA;AAAA,MACtB;AAAA;AAAA,MACA,wBAAwB,MAAM;AAAA;AAAA,MAC9B;AAAA;AAAA,IACF,EAAE,KAAK,GAAG;AAAA,EACZ;AAEA,SAAO;AAAA,IACL;AAAA;AAAA,IACA,wBAAwB,MAAM;AAAA;AAAA,IAC9B;AAAA;AAAA,IACA,gBAAgB,MAAM;AAAA;AAAA,EACxB,EAAE,KAAK,GAAG;AACZ;AAmBO,IAAM,wBAAwB,CAAC;AAAA,EACpC;AAAA,EACA;AAAA,EACA;AAAA,EACA;AACF,MAAmC;AACjC,MAAI,CAAC,SAAU,QAAO;AACtB,QAAM,kBAAkB,WAAW;AACnC,MAAI,CAAC,aAAa,SAAS,GAAG;AAC5B,WAAO,OAAO,SAAS,MAAM,GAAG,UAAU,kBAAkB,UAAU,MAAM,CAAC;AAAA,EAC/E;AAaA,SAAO,IAAI,kBAAkB,UAAU,MAAM,CAAC,SAAS,SAAS,MAAM,GAAG;AAC3E;;;ACrDM;AA5DN,IAAM,uBAA4C;AAAA,EAChD,KAAK;AAAA,EACL,OAAO;AAAA,EACP,QAAQ;AAAA,EACR,YAAY;AAAA,EACZ,QAAQ;AACV;AAEA,IAAM,yBAA8C;AAAA,EAClD,MAAM;AAAA,EACN,OAAO;AAAA,EACP,QAAQ;AAAA,EACR,WAAW;AAAA,EACX,QAAQ;AACV;AAEA,IAAM,mBAAwC;AAAA,EAC5C,UAAU;AAAA,EACV,YAAY;AAAA,EACZ,QAAQ;AAAA,EACR,SAAS;AACX;AAEA,IAAM,iBAAiB,CAAC,QAAyB,kBAA0B;AACzE,QAAM,iBAAiB,iBAAiB,MAAM;AAE9C,MAAI,gBAAgB;AAClB,WAAO,OAAO,SAAS;AAAA,EACzB;AACA,SAAO,GAAG,OAAO,MAAM,IAAI,aAAa;AAC1C;AAUO,IAAM,cAA0C,CAAC;AAAA,EACtD;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AACF,MAAM;AACJ,QAAM,cAAc,eAAe,QAAQ,aAAa;AACxD,QAAM,eAAe,aAAa,SAAS,IACvC;AAAA,IACE,GAAG;AAAA,IACH,KAAK;AAAA,EACP,IACA;AAAA,IACE,GAAG;AAAA,IACH,MAAM;AAAA,EACR;AAEJ,SAAO,YACL,4CAAC,SAAI,OAAO,EAAE,UAAU,UAAU,KAAK,GAAG,MAAM,EAAE,GAChD;AAAA,IAAC;AAAA;AAAA,MACC,OAAO;AAAA,QACL,GAAG;AAAA,QACH,UAAU;AAAA,QACV,GAAI,aAAa,SAAS,IACtB,EAAE,OAAO,WAAW,IACpB,EAAE,QAAQ,WAAW;AAAA,MAC3B;AAAA,MAEA,uDAAC,OAAE,OAAO,kBAAkB;AAAA;AAAA,QAAU;AAAA,SAAO;AAAA;AAAA,EAC/C,GACF,IAEA,4CAAC,SAAI,OAAO,EAAE,GAAG,cAAc,UAAU,QAAQ,GAC/C,uDAAC,OAAE,OAAO,kBAAkB;AAAA;AAAA,IAAU;AAAA,KAAO,GAC/C;AAEJ;;;ACjFA,IAAAC,gBAUO;AACP,yCAA0B;;;ACX1B,mBAA8B;AAOvB,IAAM,uBAAmB;AAAA,EAC9B,CAAC;AACH;;;ADaO,IAAM,OAA4B,CAAC,EAAE,UAAU,KAAK,MAAM;AAC/D,QAAM;AAAA,IACJ,8BAA8B,MAAM;AAAA,IAAC;AAAA,IACrC,qBAAqB;AAAA,IACrB,cAAc,MAAM;AAAA,IAAC;AAAA,IACrB,aAAa,MAAM;AAAA,IAAC;AAAA,IACpB,iBAAiB;AAAA,IACjB,SAAS;AAAA,IACT;AAAA,IACA,gBAAgB;AAAA,IAChB;AAAA,IACA,YAAY;AAAA,EACd,QAAI,0BAAW,gBAAgB;AAE/B,QAAM,CAAC,UAAU,WAAW,QAAI,wBAAS,CAAC;AAC1C,QAAM,aAAa,cAAc,EAAE,QAAQ,UAAU,CAAC;AACtD,QAAM,EAAE,KAAK,WAAW,MAAM,QAAI,8CAAU;AAAA,IAC1C,MAAM,SAAS;AAAA,IACf;AAAA,IACA,WAAW;AAAA,EACb,CAAC;AAED,QAAM,oBAAoB,MAAM;AAC9B,QAAI,CAAC,UAAW,QAAO;AACvB,QAAI,SAAS,SAAS;AACpB,aAAO,aAAa,SAAS,IACzB,QAAQ,QAAQ,YAChB,QAAQ,QAAQ;AAAA,IACtB;AACA,WAAO,aAAa,SAAS,IAAI,OAAO,UAAU,OAAO;AAAA,EAC3D;AAEA,QAAM,qBAAqB,MAAM;AAC/B,QAAI,aAAa,SAAS,GAAG;AAC3B,aAAO,qBAAqB,kBAAkB,IAAI,OAAO;AAAA,IAC3D;AACA,WAAO,qBAAqB,kBAAkB,IAAI,SAAS;AAAA,EAC7D;AAEA,QAAM,UAAM,sBAA2B,IAAI;AAC3C,QAAM,CAAC,gBAAgB,iBAAiB,QAAI,wBAAS,KAAK;AAE1D,QAAM,yBAAqB;AAAA,IACzB,MAAM,sBAAsB,EAAE,QAAQ,UAAU,eAAe,UAAU,CAAC;AAAA,IAC1E,CAAC,QAAQ,UAAU,eAAe,SAAS;AAAA,EAC7C;AAEA,QAAM,EAAE,KAAK,mBAAmB,OAAO,oBAAoB,QAAI,8CAAU;AAAA,IACvE,MAAM,SAAS;AAAA,IACf,YAAY;AAAA,IACZ,WAAW;AAAA,EACb,CAAC;AAED,QAAM,cAAU;AAAA,IACd,CAAC,SAAsB;AACrB,UAAI,UAAU;AACd,gBAAU,IAAI;AACd,wBAAkB,IAAI;AAAA,IACxB;AAAA,IACA,CAAC,WAAW,iBAAiB;AAAA,EAC/B;AAEA,+BAAU,MAAM;AACd,QAAI,kBAAkB,qBAAqB;AACzC,YAAM,WAAW,oBAAoB;AACrC,UAAI,gBAAgB;AAClB,uBAAe;AAAA,UACb;AAAA,UACA;AAAA,UACA,SAAS,oBAAoB;AAAA,UAC7B,OAAO;AAAA,UACP,WAAW,mBAAmB;AAAA,QAChC,CAAC;AAAA,MACH;AAAA,IACF;AAAA,EACF,GAAG,CAAC,mBAAmB,CAAC;AAExB,+BAAU,MAAM;AACd,QAAI,OAAO;AACT,YAAM,2BAA2B,MAAM;AACvC,UAAI,6BAA6B,gBAAgB;AAC/C,0BAAkB,wBAAwB;AAC1C,cAAM,YAA4C;AAAA,UAChD,SAAS,MAAM;AAAA,UACf;AAAA,UACA;AAAA,UACA,WAAW,mBAAmB;AAAA,QAChC;AACA,YAAI,0BAA0B;AAC5B,sBAAY,SAAS;AAAA,QACvB,OAAO;AACL,qBAAW,SAAS;AAAA,QACtB;AACA,oCAA4B,kBAAkB,CAAC;AAAA,MACjD;AAAA,IACF;AAAA,EACF,GAAG,CAAC,KAAK,CAAC;AAEV,qCAAgB,MAAM;AACpB,QAAI,IAAI,SAAS;AACf;AAAA,QACE,aAAa,SAAS,IAClB,IAAI,QAAQ,eACZ,IAAI,QAAQ;AAAA,MAClB;AAAA,IACF;AAAA,EACF,GAAG,CAAC,IAAI,OAAO,CAAC;AAEhB,QAAM,eAAe,uBAAS,KAAK,QAAQ;AAE3C,aAAO,4BAAa,cAAc,EAAE,KAAK,QAAQ,CAAC;AACpD;;;AErIA,IAAAC,gBAA6C;AA+EzC,IAAAC,sBAAA;AAvEG,IAAM,YAAY,CAAe;AAAA,EACtC,YAAY;AAAA,EACZ;AAAA,EACA;AAAA,EACA,SAAS;AAAA,EACT;AAAA,EACA;AAAA,EACA;AAAA,EACA,YAAY;AAAA,EACZ;AACF,MAAyB;AACvB,QAAM,0BAA0B,iBAAiB,MAAM;AACvD,QAAM,CAAC,oBAAoB,qBAAqB,QAAI,wBAAS,CAAC;AAC9D,QAAM,CAAC,eAAe,gBAAgB,QAAI,wBAAS,CAAC;AACpD,QAAM,CAAC,YAAY,aAAa,QAAI,wBAAS,CAAC;AAE9C,QAAM,mBAAe,uBAAQ,MAAM;AACjC,WAAO,aAAa,SAAS,IAAI,OAAO,cAAc,OAAO;AAAA,EAC/D,GAAG,CAAC,SAAS,CAAC;AAEd,QAAM,8BAA8B,CAAC,mBAA2B;AAC9D,0BAAsB,cAAc;AAAA,EACtC;AAEA,QAAM,eAAe,MAAM;AACzB,QAAI,SAAS,SAAS;AACpB;AAAA,QACE,aAAa,SAAS,IAClB,QAAQ,QAAQ,eAChB,QAAQ,QAAQ;AAAA,MACtB;AACA;AAAA,QACE,CAAC,aAAa,SAAS,IACnB,QAAQ,QAAQ,eAChB,QAAQ,QAAQ;AAAA,MACtB;AAAA,IACF,OAAO;AACL,uBAAiB,YAAY;AAAA,IAC/B;AAAA,EACF;AAEA,+BAAU,MAAM;AACd,QAAI,yBAAyB;AAC3B,UAAI,SAAS,SAAS;AACpB,cAAM,iBAAiB,IAAI,eAAe,MAAM;AAC9C,uBAAa;AAAA,QACf,CAAC;AACD,uBAAe,QAAQ,QAAQ,OAAO;AACtC,eAAO,MAAM;AACX,yBAAe,WAAW;AAAA,QAC5B;AAAA,MACF;AAEA,mBAAa;AACb,aAAO,iBAAiB,UAAU,YAAY;AAC9C,aAAO,MAAM;AACX,eAAO,oBAAoB,UAAU,YAAY;AAAA,MACnD;AAAA,IACF;AAAA,EACF,GAAG,CAAC,CAAC;AAEL,QAAM,cAAc,0BAChB,CAAE,OAAkB,QAAQ,MAAM,EAAE,IAAI,gBACxC,CAAC;AAEL,QAAM,wBAAoB;AAAA,IACxB,MAAM,gBAAgB,WAAW,aAAa;AAAA,IAC9C,CAAC,aAAa;AAAA,EAChB;AAEA,SACE;AAAA,IAAC,iBAAiB;AAAA,IAAjB;AAAA,MACC,OAAO;AAAA,QACL,QAAQ;AAAA,QACR;AAAA,QACA;AAAA,QACA;AAAA,QACA;AAAA,QACA;AAAA,QACA;AAAA;AAAA,QAEA;AAAA;AAAA,QAEA;AAAA;AAAA,QAEA;AAAA,MACF;AAAA,MAEC;AAAA,iBACC;AAAA,UAAC;AAAA;AAAA,YACC;AAAA,YACA;AAAA,YACA,WAAW,CAAC,CAAC;AAAA,YACb;AAAA,YACA;AAAA;AAAA,QACF;AAAA,QAED;AAAA;AAAA;AAAA,EACH;AAEJ;","names":["offset","import_react","import_react","import_jsx_runtime"]}