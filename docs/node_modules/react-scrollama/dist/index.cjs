"use strict";
var __defProp = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __export = (target, all) => {
  for (var name in all)
    __defProp(target, name, { get: all[name], enumerable: true });
};
var __copyProps = (to, from, except, desc) => {
  if (from && typeof from === "object" || typeof from === "function") {
    for (let key of __getOwnPropNames(from))
      if (!__hasOwnProp.call(to, key) && key !== except)
        __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
  }
  return to;
};
var __toCommonJS = (mod) => __copyProps(__defProp({}, "__esModule", { value: true }), mod);

// src/index.ts
var index_exports = {};
__export(index_exports, {
  DebugOffset: () => DebugOffset,
  Scrollama: () => Scrollama,
  ScrollamaProvide: () => ScrollamaProvide,
  Step: () => Step,
  createThreshold: () => createThreshold,
  getProgressRootMargin: () => getProgressRootMargin,
  getRootMargin: () => getRootMargin,
  isBrowser: () => isBrowser,
  isHorizontal: () => isHorizontal,
  isOffsetInPixels: () => isOffsetInPixels
});
module.exports = __toCommonJS(index_exports);

// src/utils.ts
function isOffsetInPixels(offset) {
  return typeof offset === "string" && offset.includes("px");
}
var createThreshold = (theta, height) => {
  const count = Math.ceil(height / theta);
  const t = [];
  const ratio = 1 / count;
  for (let i = 0; i <= count; i += 1) {
    t.push(i * ratio);
  }
  return t;
};
var isBrowser = typeof window !== "undefined" && window.document !== void 0;
var isHorizontal = (direction) => direction === "horizontal";
var getRootMargin = ({
  offset,
  direction
}) => {
  const calculateMargin = (offset2) => `${-offset2 * 100}%`;
  const calculateOppositeMargin = (offset2) => `${-(100 - offset2 * 100)}%`;
  if (isHorizontal(direction)) {
    return [
      calculateMargin(offset),
      // Top
      "0px",
      // Right
      calculateOppositeMargin(offset),
      // Bottom
      "0px"
      // Left
    ].join(" ");
  }
  return [
    "0px",
    // Top
    calculateOppositeMargin(offset),
    // Right
    "0px",
    // Bottom
    calculateMargin(offset)
    // Left
  ].join(" ");
};
var getProgressRootMargin = ({
  offset,
  nodeSize,
  containerSize,
  direction
}) => {
  if (!nodeSize) return "0px";
  const offsetSizeRatio = nodeSize / containerSize;
  if (!isHorizontal(direction)) {
    return `0px ${offset * 100 - 100}% 0px ${(offsetSizeRatio - offset) * 100 + 1}%`;
  }
  return `${(offsetSizeRatio - offset) * 100 + 1}% 0px ${offset * 100 - 100}% 0px`;
};

// src/debug-offset.tsx
var import_jsx_runtime = require("react/jsx-runtime");
var markerStylesVertical = {
  top: 0,
  width: 0,
  height: "100%",
  borderLeft: "2px dashed black",
  zIndex: 9999
};
var markerStylesHorizontal = {
  left: 0,
  width: "100%",
  height: 0,
  borderTop: "2px dashed black",
  zIndex: 9999
};
var offsetTextStyles = {
  fontSize: "12px",
  fontFamily: "monospace",
  margin: 0,
  padding: 6
};
var getOffsetValue = (offset, containerSize) => {
  const offsetInPixels = isOffsetInPixels(offset);
  if (offsetInPixels) {
    return offset.toString();
  }
  return `${Number(offset) * containerSize}px`;
};
var DebugOffset = ({
  offset,
  direction,
  stickySize,
  isHasRoot,
  containerSize
}) => {
  const offsetValue = getOffsetValue(offset, containerSize);
  const commonStyles = isHorizontal(direction) ? {
    ...markerStylesHorizontal,
    top: offsetValue
  } : {
    ...markerStylesVertical,
    left: offsetValue
  };
  return isHasRoot ? /* @__PURE__ */ (0, import_jsx_runtime.jsx)("div", { style: { position: "sticky", top: 0, left: 0 }, children: /* @__PURE__ */ (0, import_jsx_runtime.jsx)(
    "div",
    {
      style: {
        ...commonStyles,
        position: "absolute",
        ...isHorizontal(direction) ? { width: stickySize } : { height: stickySize }
      },
      children: /* @__PURE__ */ (0, import_jsx_runtime.jsxs)("p", { style: offsetTextStyles, children: [
        "trigger: ",
        offset
      ] })
    }
  ) }) : /* @__PURE__ */ (0, import_jsx_runtime.jsx)("div", { style: { ...commonStyles, position: "fixed" }, children: /* @__PURE__ */ (0, import_jsx_runtime.jsxs)("p", { style: offsetTextStyles, children: [
    "trigger: ",
    offset
  ] }) });
};

// src/step.tsx
var import_react2 = require("react");
var import_react_intersection_observer = require("react-intersection-observer");

// src/provide.tsx
var import_react = require("react");
var ScrollamaProvide = (0, import_react.createContext)(
  {}
);

// src/step.tsx
var Step = ({ children, data }) => {
  const {
    handleSetLastScrollPosition = () => {
    },
    lastScrollPosition = 0,
    onStepEnter = () => {
    },
    onStepExit = () => {
    },
    onStepProgress = null,
    offset = 0.3,
    progressThreshold,
    containerSize = 0,
    rootRef,
    direction = "horizontal"
  } = (0, import_react2.useContext)(ScrollamaProvide);
  const [nodeSize, setNodeSize] = (0, import_react2.useState)(0);
  const rootMargin = getRootMargin({ offset, direction });
  const { ref: inViewRef, entry } = (0, import_react_intersection_observer.useInView)({
    root: rootRef?.current,
    rootMargin,
    threshold: 0
  });
  const getScrollPosition = () => {
    if (!isBrowser) return 0;
    if (rootRef?.current) {
      return isHorizontal(direction) ? rootRef.current.scrollTop : rootRef.current.scrollLeft;
    }
    return isHorizontal(direction) ? window.scrollY : window.scrollX;
  };
  const getScrollDirection = () => {
    if (isHorizontal(direction)) {
      return lastScrollPosition > getScrollPosition() ? "up" : "down";
    }
    return lastScrollPosition > getScrollPosition() ? "left" : "right";
  };
  const ref = (0, import_react2.useRef)(null);
  const [isIntersecting, setIsIntersecting] = (0, import_react2.useState)(false);
  const progressRootMargin = (0, import_react2.useMemo)(
    () => getProgressRootMargin({ offset, nodeSize, containerSize, direction }),
    [offset, nodeSize, containerSize, direction]
  );
  const { ref: scrollProgressRef, entry: scrollProgressEntry } = (0, import_react_intersection_observer.useInView)({
    root: rootRef?.current,
    rootMargin: progressRootMargin,
    threshold: progressThreshold
  });
  const setRefs = (0, import_react2.useCallback)(
    (node) => {
      ref.current = node;
      inViewRef(node);
      scrollProgressRef(node);
    },
    [inViewRef, scrollProgressRef]
  );
  (0, import_react2.useEffect)(() => {
    if (isIntersecting && scrollProgressEntry) {
      const progress = scrollProgressEntry.intersectionRatio;
      if (onStepProgress) {
        onStepProgress({
          progress,
          data,
          element: scrollProgressEntry.target,
          entry: scrollProgressEntry,
          direction: getScrollDirection()
        });
      }
    }
  }, [scrollProgressEntry]);
  (0, import_react2.useEffect)(() => {
    if (entry) {
      const currentIntersectionState = entry.isIntersecting;
      if (currentIntersectionState !== isIntersecting) {
        setIsIntersecting(currentIntersectionState);
        const eventData = {
          element: entry.target,
          data,
          entry,
          direction: getScrollDirection()
        };
        if (currentIntersectionState) {
          onStepEnter(eventData);
        } else {
          onStepExit(eventData);
        }
        handleSetLastScrollPosition(getScrollPosition());
      }
    }
  }, [entry]);
  (0, import_react2.useLayoutEffect)(() => {
    if (ref.current) {
      setNodeSize(
        isHorizontal(direction) ? ref.current.offsetHeight : ref.current.offsetWidth
      );
    }
  }, [ref.current]);
  const childElement = import_react2.Children.only(children);
  return (0, import_react2.cloneElement)(childElement, { ref: setRefs });
};

// src/scrollama.tsx
var import_react3 = require("react");
var import_jsx_runtime2 = require("react/jsx-runtime");
var Scrollama = ({
  direction = "horizontal",
  debug,
  children,
  offset = 0.3,
  onStepEnter,
  onStepExit,
  onStepProgress,
  threshold = 4,
  rootRef
}) => {
  const isOffsetDefinedInPixels = isOffsetInPixels(offset);
  const [lastScrollPosition, setLastScrollPosition] = (0, import_react3.useState)(0);
  const [containerSize, setContainerSize] = (0, import_react3.useState)(1);
  const [stickySize, setStickySize] = (0, import_react3.useState)(0);
  const viewportSize = (0, import_react3.useMemo)(() => {
    return isHorizontal(direction) ? window.innerHeight : window.innerWidth;
  }, [direction]);
  const handleSetLastScrollPosition = (scrollPosition) => {
    setLastScrollPosition(scrollPosition);
  };
  const handleResize = () => {
    if (rootRef?.current) {
      setContainerSize(
        isHorizontal(direction) ? rootRef.current.clientHeight : rootRef.current.clientWidth
      );
      setStickySize(
        !isHorizontal(direction) ? rootRef.current.clientHeight : rootRef.current.clientWidth
      );
    } else {
      setContainerSize(viewportSize);
    }
  };
  (0, import_react3.useEffect)(() => {
    if (isOffsetDefinedInPixels) {
      if (rootRef?.current) {
        const resizeObserver = new ResizeObserver(() => {
          handleResize();
        });
        resizeObserver.observe(rootRef.current);
        return () => {
          resizeObserver.disconnect();
        };
      }
      handleResize();
      window.addEventListener("resize", handleResize);
      return () => {
        window.removeEventListener("resize", handleResize);
      };
    }
  }, []);
  const offsetValue = isOffsetDefinedInPixels ? +offset.replace("px", "") / containerSize : +offset;
  const progressThreshold = (0, import_react3.useMemo)(
    () => createThreshold(threshold, containerSize),
    [containerSize]
  );
  return /* @__PURE__ */ (0, import_jsx_runtime2.jsxs)(
    ScrollamaProvide.Provider,
    {
      value: {
        offset: offsetValue,
        lastScrollPosition,
        handleSetLastScrollPosition,
        progressThreshold,
        containerSize,
        rootRef,
        direction,
        // @ts-ignore ts(2345)
        onStepEnter,
        // @ts-ignore ts(2345)
        onStepExit,
        // @ts-ignore ts(2345)
        onStepProgress
      },
      children: [
        debug && /* @__PURE__ */ (0, import_jsx_runtime2.jsx)(
          DebugOffset,
          {
            offset,
            direction,
            isHasRoot: !!rootRef,
            stickySize,
            containerSize
          }
        ),
        children
      ]
    }
  );
};
// Annotate the CommonJS export names for ESM import in node:
0 && (module.exports = {
  DebugOffset,
  Scrollama,
  ScrollamaProvide,
  Step,
  createThreshold,
  getProgressRootMargin,
  getRootMargin,
  isBrowser,
  isHorizontal,
  isOffsetInPixels
});
//# sourceMappingURL=index.cjs.map